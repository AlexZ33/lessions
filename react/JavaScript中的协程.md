<!--
 * @Author: AlexZ33 775136985@qq.com
 * @Date: 2022-08-09 15:30:48
 * @LastEditors: AlexZ33 775136985@qq.com
 * @LastEditTime: 2022-08-09 15:50:41
 * @FilePath: /react/协程.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
线程切换是由操作系统的时间片控制的，而协程是程序自己实现的，让协程不断轮流执行才是实现并发，所以实现协程还必须要有一个类似于时间片的结构，不同于线程的切换，协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。

# 协程长啥样
直接上代码看看 JavaScript 中协程是怎样的：

```javascript
// 没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。
function * idMaker() {
    let index = 0;
    while (true) {
        yield index++;
    }
}

let gen = idMaker(); // "Generator { }"

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
```
没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。

<b>什么是协程</b>

总结一句话, 协程就是满足下面条件的函数:

- 可以暂停执行（暂停的表达式称为暂停点)
- 可以从挂起点恢复（保留其原始参数和局部变量）
- 事件循环是异步编程的底层基石

> 注意这里需要解释下: 
> 近几年为何协程的概念可以大热。我认为一个特殊的场景使得协程能够广泛的发挥其优势，并且屏蔽掉了劣势 --> 网络编程。与一般的计算机程序相比，网络编程有其独有的特点。
> - 高并发（每秒钟上千数万的单机访问量）
> - Request/Response。程序生命期端（毫秒，秒级）
> - 高IO，低计算（连接数据库，请求API）。
> 
最开始的网络程序其实就是一个线程一个请求设计的（Apache）。后来，随着网络的普及，诞生了C10K问题。Nginx 通过单线程异步 IO 把网络程序的执行流程进行了乱序化，通过 IO 事件机制最大化的保证了CPU的利用率。

至此，现代网络程序的架构已经形成。基于IO事件调度的异步编程。其代表作恐怕就属 NodeJS 了吧。

<b>异步编程的问题</b>

异步编程为了追求程序的性能，强行的将线性的程序打乱，程序变得非常的混乱与复杂。对程序状态的管理也变得异常困难。写过Nginx C Module的同学应该知道我说的是什么。我们开始吐槽 NodeJS 那恶心的层层Callback。（**js 和nodejs后来提出promise方案解决这个问题**）

但是与此同时，Golang 作为名门之后开始走入我们的视野。并且迅速的在Web后端极速的跑马圈地。其代表者 Docker 以及围绕这 Docker 展开的整个容器生态圈欣欣向荣起来。其最大的卖点 – 协程 开始真正的流行与讨论起来。

我们开始向写PHP一样来写全异步IO的程序。看上去美好极了，仿佛世界就是这样了。

　　在网络编程中，我们可以理解为 Golang 的协程本质上其实就是对 IO 事件的封装，并且通过语言级的支持让异步的代码看上去像同步执行的一样。

<b>也就是说协程是另一个解决方案，我们这里准备用javascript实现一个协程 </b>



# 协程如何切换
协程本身是个函数，协程之间的切换本质是函数执行权的转移。
