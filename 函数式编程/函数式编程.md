<!--
 * @Author: AlexZ33 775136985@qq.com
 * @Date: 2022-08-09 11:50:57
 * @LastEditors: AlexZ33 775136985@qq.com
 * @LastEditTime: 2022-08-09 11:52:46
 * @FilePath: /函数式编程/函数式编程.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
基础看这里[函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)


函数式编程
-----

基础看这里[函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)

###高阶函数

常规函数参数一般只接受基本的数据类型或对象引用。
下面是常规的参数传递和返回：

```
function foo(x) {
  return x;
}
```
高阶函数则可以**把函数作为参数**，或是将函数作为返回值：

```
function foo(x) {
  return function () {
    return x;
  };
}
```
####后续传递风格编程
后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中：

```
function foo(x,bar) {
  return bar(x);
}
```
相对于相同的foo函数，传入的bar参数不同，则可以得到不同的结果。一个经典的例子就是数组的[sort()](http://www.w3school.com.cn/jsref/jsref_sort.asp)方法

```
var points = [40,100,1,5,25,10];
points.sort(function(a, b) {
  return a - b;
});
```
通过改动sort()方法的参数，可以决定不同排序方式，从这里可以看出高阶函数的灵活性。
Node中事件的处理方式正是基于高阶函数的特性来完成。通过为相同事件注册不同的回调函数，可以灵活的处理业务逻辑。

```
var emitter = new events.EventEmitter();
emitter.on('event_foo', function () {
  //to do something
});
```

高阶函数在JavaScipt中有很多，其中ECMAScript5中提供的一些数组方法十分典型。
- forEach()
- reduce()
- reduceRight()
- filter()
- every()
- some()
###偏函数

先上定义：
**通过指定部分参数来产生一个新的定制函数的形式就是偏函数**

```
var toString = Object.prototype.toString;

var isString = function (obj) {
  return toString.call(obj) == '[object String]';
};

var isFunction = function (obj) {
  return toString.call(obj) == '[object Function]';
};

```
在javascript中进行类型判断时候，我们通常会像上面代码这样定义方法。这两个函数的定义，重复定义了相似的函数，如果有更多的is***()就会产生很多冗余代码。

我们可以用isType()函数来预先指定type的值

```
var isType = function (type) {
  return function (obj) {
   return toString.call(obj) == '[object' + type ']';
  };
};

var isString = isType('String');
var isFunction = isTyp('Function');
```
可以看出引入isType()函数以后，创建isString()、isFunction()函数就变的简单很多。

偏函数应用在异步编程中也很常见。
