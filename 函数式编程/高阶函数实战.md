<!--
 * @Author: AlexZ33 775136985@qq.com
 * @Date: 2022-08-09 13:18:28
 * @LastEditors: AlexZ33 775136985@qq.com
 * @LastEditTime: 2022-08-09 13:45:48
 * @FilePath: /函数式编程/高阶函数实战.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<!--
 * @Author: AlexZ33 775136985@qq.com
 * @Date: 2022-08-09 13:18:28
 * @LastEditors: AlexZ33 775136985@qq.com
 * @LastEditTime: 2022-08-09 13:41:04
 * @FilePath: /函数式编程/高阶函数实战.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

基础看上一篇文章 [函数式编程](https://zhuanlan.zhihu.com/p/551605596)

# 一、高阶函数是什么

**满足以下条件之一的即为高阶函数：**
  - 接收一个或多个函数作为输入
  - 输出是一个函数

接收一个或者多个函数作为函数输入，这种场景我们用到的函数比较多，如Array里的filter, some, every, forEach, map, reduce等皆为高阶函数，

常见的还有 Promise, setTimeout, setInterval,arr.map() 等等

 这类函数主要的作用就是将函数内部的某一小部分逻辑变得可配置化，实现通用逻辑的复用。

```javascript
[1, 2, 3, 4].filter((item) => item % 2 === 0);
```

很显然，array.filter接收的是一个判断过滤条件的函数，函数内置的一段复用逻辑：遍历整个数组，找出符合条件的数组项并进行返回。符合的条件： 输入的函数进行的条件判断。

而<b>输出为一个函数的高阶函数我们用得最多的可能就是节流throttle和防抖debounce了</b>

```javascript
/**
 * @desc 简易版函数防抖
 * @param fn 函数
 * @param delay 延迟执行毫秒数
 */
function debounce(fn, delay = 1000) {
  let timer = null;
  return function () {
    const args = arguments;
    const context = this;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      fn.call(context, args);
    }, delay);
  };
}
```
这类函数从形式上看就像一个函数生成器，新生成的函数内部包含了一段通用逻辑的逻辑复用。这段通用的逻辑可以是任意形式的，可能是对实际执行函数的结果再次封装（类似装饰器）、可能是对实际执行函数的一种调用时机的判断、也可能是某段具体使用场景的业务处理

**防抖函数的特征：**

-   1. 利用闭包生成全局变量: 为每次新生成的那个函数提供一个全局变量，当此函数进行调用时，可根据此变量的值的不同进行合理的事件响应
-   2. 可复用的逻辑：对于短时间内的多次函数调用，只对最后一次事件（或最早的一段事件）进行响应， 新生成的函数其实是对传入的函数的再次包装，
# 二、高阶函数意义

任何一个高阶函数，其最终的目的都是为了尽量复用某一段代码逻辑，在复用代码逻辑的同时，以更简洁明了的形式编写代码来增加代码可读性与可维护性。
-  1. 复用可复用逻辑，将常见场景解决方案固定化，避免出现不可预料的问题
-    2. 清晰代码逻辑，写出更具语义化代码
-    3. 对业务逻辑进行合理拆分，尽可能的将有关联的代码内聚，代码模块化，提高代码可维护性

```javascript
const main = () => {
  const array = [1, 2, 3, 4, 5];
  const res = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] % 2 === 0) {
      res.push(array[i]);
    }
  }
  console.log(res);

  const r = array.filter((item) => item % 2 === 0);
  console.log(r);
};
main();
```
# 三、常见应用场景

## 3.1 根据函数执行完成的时间进行节流
## 3.2 响应最后一次请求的返回

## 3.3 根据优先级取值 getValueByPriority

## 3.4 Compose函数(聚合函数) 

## 3.5 失败后重试 retry

## 3.6 带缓存的网络请求

## 3.7 根据请求参数进行缓存

## 3.8 请求聚合函数

## 3.9 函数柯里化

通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 

```javascript
function sum (a) {
    return (b) =>  {
        return (c) => {
            return a+b+c
        }
    }
}

const result = sum(1)(2)(3)

console.log(result)


```
**案例**

使用函数柯里化实现

```javascript
 1 <script type="text/babel">
 2         //创建组件
 3         class Login extends React.Component{
 4             //初始化状态
 5             state = {
 6                 username:'', //用户名
 7                 password:'' //密码
 8             }
 9 
10             //保存表单数据到状态中
11             saveFormData = (dataType)=>{
12                 return (event)=>{
13                     this.setState({[dataType]:event.target.value})
14                 }
15             }
16 
17             //表单提交的回调
18             handleSubmit = (event)=>{
19                 event.preventDefault() //阻止表单提交
20                 const {username,password} = this.state
21                 alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
22             }
23             render(){
24                 return(
25                     <form onSubmit={this.handleSubmit}>
26                         用户名：<input onChange={this.saveFormData('username')} type="text" name="username"/>
27                         密码：<input onChange={this.saveFormData('password')} type="password" name="password"/>
28                         <button>登录</button>
29                     </form>
30                 )
31             }
32         }
33         //渲染组件
34         ReactDOM.render(<Login/>,document.getElementById('test'))
35     </script>
```
不用函数柯里化实现

```javascript
 1 <script type="text/babel">
 2         //创建组件
 3         class Login extends React.Component{
 4             //初始化状态
 5             state = {
 6                 username:'', //用户名
 7                 password:'' //密码
 8             }
 9 
10             //保存表单数据到状态中
11             saveFormData = (dataType,event)=>{
12                 this.setState({[dataType]:event.target.value})
13             }
14 
15             //表单提交的回调
16             handleSubmit = (event)=>{
17                 event.preventDefault() //阻止表单提交
18                 const {username,password} = this.state
19                 alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
20             }
21             render(){
22                 return(
23                     <form onSubmit={this.handleSubmit}>
24                         用户名：<input onChange={event => this.saveFormData('username',event) } type="text" name="username"/>
25                         密码：<input onChange={event => this.saveFormData('password',event) } type="password" name="password"/>
26                         <button>登录</button>
27                     </form>
28                 )
29             }
30         }
31         //渲染组件
32         ReactDOM.render(<Login/>,document.getElementById('test'))
33     </script>
```
# 四、总结

# 参考



